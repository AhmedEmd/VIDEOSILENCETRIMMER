"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callCompositor = exports.compose = exports.composeWithoutCache = exports.serializeCommand = void 0;
const node_child_process_1 = require("node:child_process");
const node_crypto_1 = require("node:crypto");
const promises_1 = require("node:fs/promises");
const node_path_1 = __importDefault(require("node:path"));
const get_executable_path_1 = require("./get-executable-path");
const make_file_executable_1 = require("./make-file-executable");
const make_nonce_1 = require("./make-nonce");
const getCompositorHash = ({ ...input }) => {
    return (0, node_crypto_1.createHash)('sha256').update(JSON.stringify(input)).digest('base64');
};
const serializeCommand = (command, params) => {
    return {
        nonce: (0, make_nonce_1.makeNonce)(),
        payload: {
            type: command,
            params,
        },
    };
};
exports.serializeCommand = serializeCommand;
const composeWithoutCache = async ({ height, width, layers, output, imageFormat, compositor, }) => {
    await compositor.executeCommand('Compose', {
        height,
        width,
        layers,
        output,
        output_format: imageFormat,
    });
};
exports.composeWithoutCache = composeWithoutCache;
const compose = async ({ height, width, layers, output, downloadMap, imageFormat, compositor, }) => {
    const hash = getCompositorHash({ height, width, layers, imageFormat });
    if (downloadMap.compositorCache[hash]) {
        await (0, promises_1.copyFile)(downloadMap.compositorCache[hash], output);
        return;
    }
    await (0, exports.composeWithoutCache)({
        compositor,
        height,
        imageFormat,
        layers,
        output,
        width,
    });
    downloadMap.compositorCache[hash] = output;
};
exports.compose = compose;
const callCompositor = (payload, indent, logLevel, binariesDirectory) => {
    return new Promise((resolve, reject) => {
        const execPath = (0, get_executable_path_1.getExecutablePath)({
            type: 'compositor',
            indent,
            logLevel,
            binariesDirectory,
        });
        (0, make_file_executable_1.makeFileExecutableIfItIsNot)(execPath);
        const child = (0, node_child_process_1.spawn)(execPath, [payload], {
            cwd: node_path_1.default.dirname(execPath),
        });
        const stderrChunks = [];
        child.stderr.on('data', (d) => stderrChunks.push(d));
        child.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                const message = Buffer.concat(stderrChunks).toString('utf-8');
                try {
                    // Try to see if the error is a JSON
                    const parsed = JSON.parse(message);
                    const msg = `Compositor error: ${parsed.error}`;
                    const err = new Error(`${msg}\n${parsed.backtrace}`);
                    reject(err);
                }
                catch (err) {
                    reject(new Error(`Compositor panicked with code ${code}: ${message}`));
                }
            }
        });
        if (child.stdin.closed) {
            reject(new Error('Compositor stdin closed unexpectedly,' +
                Buffer.concat(stderrChunks).toString('utf-8')));
            return;
        }
        try {
            child.stdin.write(payload, (e) => {
                if (e) {
                    if (e instanceof Error && e.message.includes('EPIPE')) {
                        reject(new Error('Compositor stdin closed unexpectedly,' +
                            Buffer.concat(stderrChunks).toString('utf-8')));
                    }
                    return;
                }
                child.stdin.end();
            });
        }
        catch (err) {
            if (err instanceof Error && err.message.includes('EPIPE')) {
                reject(new Error('Compositor stdin closed unexpectedly,' +
                    Buffer.concat(stderrChunks).toString('utf-8')));
            }
        }
    });
};
exports.callCompositor = callCompositor;
