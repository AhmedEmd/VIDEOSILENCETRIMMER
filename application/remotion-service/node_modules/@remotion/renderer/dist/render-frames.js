"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderFrames = exports.internalRenderFrames = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const perf_hooks_1 = require("perf_hooks");
const no_react_1 = require("remotion/no-react");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const browser_1 = require("./browser");
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const browser_download_progress_bar_1 = require("./browser/browser-download-progress-bar");
const is_target_closed_err_1 = require("./browser/is-target-closed-err");
const compress_assets_1 = require("./compress-assets");
const cycle_browser_tabs_1 = require("./cycle-browser-tabs");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const filter_asset_types_1 = require("./filter-asset-types");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_concurrency_1 = require("./get-concurrency");
const get_duration_from_frame_range_1 = require("./get-duration-from-frame-range");
const get_extra_frames_to_capture_1 = require("./get-extra-frames-to-capture");
const get_frame_padded_index_1 = require("./get-frame-padded-index");
const get_frame_to_render_1 = require("./get-frame-to-render");
const is_delay_render_error_with_retry_1 = require("./is-delay-render-error-with-retry");
const jpeg_quality_1 = require("./jpeg-quality");
const logger_1 = require("./logger");
const make_cancel_signal_1 = require("./make-cancel-signal");
const open_browser_1 = require("./open-browser");
const perf_1 = require("./perf");
const pool_1 = require("./pool");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const replace_browser_1 = require("./replace-browser");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const take_frame_and_compose_1 = require("./take-frame-and-compose");
const truthy_1 = require("./truthy");
const validate_1 = require("./validate");
const validate_scale_1 = require("./validate-scale");
const wrap_with_error_handling_1 = require("./wrap-with-error-handling");
const MAX_RETRIES_PER_FRAME = 1;
const innerRenderFrames = async ({ onFrameUpdate, outputDir, onStart, serializedInputPropsWithCustomSchema, serializedResolvedPropsWithCustomSchema, jpegQuality, imageFormat, frameRange, onError, envVariables, onBrowserLog, onFrameBuffer, onDownload, pagesArray, serveUrl, composition, timeoutInMilliseconds, scale, resolvedConcurrency, everyNthFrame, proxyPort, cancelSignal, downloadMap, muted, makeBrowser, browserReplacer, compositor, sourceMapGetter, logLevel, indent, parallelEncodingEnabled, compositionStart, forSeamlessAacConcatenation, onArtifact, binariesDirectory, }) => {
    if (outputDir) {
        if (!node_fs_1.default.existsSync(outputDir)) {
            node_fs_1.default.mkdirSync(outputDir, {
                recursive: true,
            });
        }
    }
    const downloadPromises = [];
    const realFrameRange = (0, get_frame_to_render_1.getRealFrameRange)(composition.durationInFrames, frameRange);
    const { extraFramesToCaptureAssetsBackend, extraFramesToCaptureAssetsFrontend, chunkLengthInSeconds, trimLeftOffset, trimRightOffset, } = (0, get_extra_frames_to_capture_1.getExtraFramesToCapture)({
        fps: composition.fps,
        compositionStart,
        realFrameRange,
        forSeamlessAacConcatenation,
    });
    const framesToRender = (0, get_duration_from_frame_range_1.getFramesToRender)(realFrameRange, everyNthFrame);
    const lastFrame = framesToRender[framesToRender.length - 1];
    const makePage = async (context, initialFrame) => {
        const page = await browserReplacer
            .getBrowser()
            .newPage(context, logLevel, indent);
        pagesArray.push(page);
        await page.setViewport({
            width: composition.width,
            height: composition.height,
            deviceScaleFactor: scale,
        });
        const logCallback = (log) => {
            onBrowserLog === null || onBrowserLog === void 0 ? void 0 : onBrowserLog({
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        };
        if (onBrowserLog) {
            page.on('console', logCallback);
        }
        await (0, set_props_and_env_1.setPropsAndEnv)({
            serializedInputPropsWithCustomSchema,
            envVariables,
            page,
            serveUrl,
            initialFrame,
            timeoutInMilliseconds,
            proxyPort,
            retriesRemaining: 2,
            audioEnabled: !muted,
            videoEnabled: imageFormat !== 'none',
            indent,
            logLevel,
            onServeUrlVisited: () => undefined,
        });
        await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
            // eslint-disable-next-line max-params
            pageFunction: (id, props, durationInFrames, fps, height, width, defaultCodec) => {
                window.remotion_setBundleMode({
                    type: 'composition',
                    compositionName: id,
                    serializedResolvedPropsWithSchema: props,
                    compositionDurationInFrames: durationInFrames,
                    compositionFps: fps,
                    compositionHeight: height,
                    compositionWidth: width,
                    compositionDefaultCodec: defaultCodec,
                });
            },
            args: [
                composition.id,
                serializedResolvedPropsWithCustomSchema,
                composition.durationInFrames,
                composition.fps,
                composition.height,
                composition.width,
                composition.defaultCodec,
            ],
            frame: null,
            page,
            timeoutInMilliseconds,
        });
        page.off('console', logCallback);
        return page;
    };
    const concurrencyOrFramesToRender = Math.min(framesToRender.length, resolvedConcurrency);
    const getPool = async (context) => {
        const pages = new Array(concurrencyOrFramesToRender)
            .fill(true)
            .map((_, i) => makePage(context, framesToRender[i]));
        const puppeteerPages = await Promise.all(pages);
        const pool = new pool_1.Pool(puppeteerPages);
        return pool;
    };
    // If rendering a GIF and skipping frames, we must ensure it starts from 0
    // and then is consecutive so FFMPEG recognizes the sequence
    const countType = everyNthFrame === 1 ? 'actual-frames' : 'from-zero';
    const filePadLength = (0, get_frame_padded_index_1.getFilePadLength)({
        lastFrame,
        totalFrames: framesToRender.length,
        countType,
    });
    let framesRendered = 0;
    const poolPromise = getPool(sourceMapGetter);
    onStart === null || onStart === void 0 ? void 0 : onStart({
        frameCount: framesToRender.length,
        parallelEncoding: parallelEncodingEnabled,
        resolvedConcurrency,
    });
    const assets = [];
    let stopped = false;
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        stopped = true;
    });
    const frameDir = outputDir !== null && outputDir !== void 0 ? outputDir : downloadMap.compositingDir;
    const renderFrameWithOptionToReject = async ({ frame, index, reject, width, height, compId, assetsOnly, attempt, }) => {
        const pool = await poolPromise;
        const freePage = await pool.acquire();
        if (stopped) {
            return reject(new Error('Render was stopped'));
        }
        const startTime = perf_hooks_1.performance.now();
        const errorCallbackOnFrame = (err) => {
            reject(err);
        };
        const cleanupPageError = (0, handle_javascript_exception_1.handleJavascriptException)({
            page: freePage,
            onError: errorCallbackOnFrame,
            frame,
        });
        freePage.on('error', errorCallbackOnFrame);
        const startSeeking = Date.now();
        await (0, seek_to_frame_1.seekToFrame)({
            frame,
            page: freePage,
            composition: compId,
            timeoutInMilliseconds,
            indent,
            logLevel,
            attempt,
        });
        const timeToSeek = Date.now() - startSeeking;
        if (timeToSeek > 1000) {
            logger_1.Log.verbose({ indent, logLevel }, `Seeking to frame ${frame} took ${timeToSeek}ms`);
        }
        if (!outputDir && !onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Called renderFrames() without specifying either `outputDir` or `onFrameBuffer`');
        }
        if (outputDir && onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Pass either `outputDir` or `onFrameBuffer` to renderFrames(), not both.');
        }
        const id = (0, perf_1.startPerfMeasure)('save');
        const { buffer, collectedAssets } = await (0, take_frame_and_compose_1.takeFrameAndCompose)({
            frame,
            freePage,
            height,
            imageFormat: assetsOnly ? 'none' : imageFormat,
            output: index === null
                ? null
                : node_path_1.default.join(frameDir, (0, get_frame_padded_index_1.getFrameOutputFileName)({
                    frame,
                    imageFormat,
                    index,
                    countType,
                    lastFrame,
                    totalFrames: framesToRender.length,
                })),
            jpegQuality,
            width,
            scale,
            downloadMap,
            wantsBuffer: Boolean(onFrameBuffer),
            compositor,
            timeoutInMilliseconds,
        });
        if (onFrameBuffer && !assetsOnly) {
            if (!buffer) {
                throw new Error('unexpected null buffer');
            }
            onFrameBuffer(buffer, frame);
        }
        (0, perf_1.stopPerfMeasure)(id);
        const previousAudioRenderAssets = assets
            .filter(truthy_1.truthy)
            .map((a) => a.audioAndVideoAssets)
            .flat(2);
        const previousArtifactAssets = assets
            .filter(truthy_1.truthy)
            .map((a) => a.artifactAssets)
            .flat(2);
        const audioAndVideoAssets = (0, filter_asset_types_1.onlyAudioAndVideoAssets)(collectedAssets);
        const artifactAssets = (0, filter_asset_types_1.onlyArtifact)(collectedAssets);
        for (const artifact of artifactAssets) {
            for (const previousArtifact of previousArtifactAssets) {
                if (artifact.filename === previousArtifact.filename) {
                    reject(new Error(`An artifact with output "${artifact.filename}" was already registered at frame ${previousArtifact.frame}, but now registered again at frame ${artifact.frame}. Artifacts must have unique names. https://remotion.dev/docs/artifacts`));
                    return;
                }
            }
            onArtifact === null || onArtifact === void 0 ? void 0 : onArtifact(artifact);
        }
        const compressedAssets = audioAndVideoAssets.map((asset) => {
            return (0, compress_assets_1.compressAsset)(previousAudioRenderAssets, asset);
        });
        assets.push({
            audioAndVideoAssets: compressedAssets,
            frame,
            artifactAssets: artifactAssets.map((a) => {
                return {
                    frame: a.frame,
                    filename: a.filename,
                };
            }),
        });
        for (const renderAsset of compressedAssets) {
            (0, download_and_map_assets_to_file_1.downloadAndMapAssetsToFileUrl)({
                renderAsset,
                onDownload,
                downloadMap,
                indent,
                logLevel,
                binariesDirectory,
                cancelSignalForAudioAnalysis: cancelSignal,
                shouldAnalyzeAudioImmediately: true,
            }).catch((err) => {
                const truncateWithEllipsis = renderAsset.src.substring(0, 1000) +
                    (renderAsset.src.length > 1000 ? '...' : '');
                onError(new Error(`Error while downloading ${truncateWithEllipsis}: ${err.stack}`));
            });
        }
        if (!assetsOnly) {
            framesRendered++;
            onFrameUpdate === null || onFrameUpdate === void 0 ? void 0 : onFrameUpdate(framesRendered, frame, perf_hooks_1.performance.now() - startTime);
        }
        cleanupPageError();
        freePage.off('error', errorCallbackOnFrame);
        pool.release(freePage);
    };
    const renderFrame = ({ frame, index, assetsOnly, attempt, }) => {
        return new Promise((resolve, reject) => {
            renderFrameWithOptionToReject({
                frame,
                index,
                reject,
                width: composition.width,
                height: composition.height,
                compId: composition.id,
                assetsOnly,
                attempt,
            })
                .then(() => {
                resolve();
            })
                .catch((err) => {
                reject(err);
            });
        });
    };
    const renderFrameAndRetryTargetClose = async ({ frame, index, retriesLeft, attempt, assetsOnly, }) => {
        var _a;
        try {
            await Promise.race([
                renderFrame({ frame, index, assetsOnly, attempt }),
                new Promise((_, reject) => {
                    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
                        reject(new Error(make_cancel_signal_1.cancelErrorMessages.renderFrames));
                    });
                }),
            ]);
        }
        catch (err) {
            const isTargetClosedError = (0, is_target_closed_err_1.isTargetClosedErr)(err);
            const shouldRetryError = (_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes(no_react_1.NoReactInternals.DELAY_RENDER_RETRY_TOKEN);
            if ((0, make_cancel_signal_1.isUserCancelledRender)(err) && !shouldRetryError) {
                throw err;
            }
            if (!isTargetClosedError && !shouldRetryError) {
                throw err;
            }
            if (stopped) {
                return;
            }
            if (retriesLeft === 0) {
                logger_1.Log.warn({
                    indent,
                    logLevel,
                }, `The browser crashed ${attempt} times while rendering frame ${frame}. Not retrying anymore. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
                throw err;
            }
            if (shouldRetryError) {
                const pool = await poolPromise;
                // Replace the closed page
                const newPage = await makePage(sourceMapGetter, frame);
                pool.release(newPage);
                logger_1.Log.warn({ indent, logLevel }, `delayRender() timed out while rendering frame ${frame}: ${err.message}`);
                const actualRetriesLeft = (0, is_delay_render_error_with_retry_1.getRetriesLeftFromError)(err);
                return renderFrameAndRetryTargetClose({
                    frame,
                    index,
                    retriesLeft: actualRetriesLeft,
                    attempt: attempt + 1,
                    assetsOnly,
                });
            }
            logger_1.Log.warn({ indent, logLevel }, `The browser crashed while rendering frame ${frame}, retrying ${retriesLeft} more times. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
            // Replace the entire browser
            await browserReplacer.replaceBrowser(makeBrowser, async () => {
                const pages = new Array(concurrencyOrFramesToRender)
                    .fill(true)
                    .map(() => makePage(sourceMapGetter, frame));
                const puppeteerPages = await Promise.all(pages);
                const pool = await poolPromise;
                for (const newPage of puppeteerPages) {
                    pool.release(newPage);
                }
            });
            await renderFrameAndRetryTargetClose({
                frame,
                index,
                retriesLeft: retriesLeft - 1,
                attempt: attempt + 1,
                assetsOnly,
            });
        }
    };
    // Render the extra frames at the beginning of the video first,
    // then the regular frames, then the extra frames at the end of the video.
    // While the order technically doesn't matter, components such as <Video> are
    // not always frame perfect and give a flicker.
    // We reduce the chance of flicker by rendering the frames in order.
    await Promise.all(extraFramesToCaptureAssetsFrontend.map((frame) => {
        return renderFrameAndRetryTargetClose({
            frame,
            index: null,
            retriesLeft: MAX_RETRIES_PER_FRAME,
            attempt: 1,
            assetsOnly: true,
        });
    }));
    await Promise.all(framesToRender.map((frame, index) => {
        return renderFrameAndRetryTargetClose({
            frame,
            index,
            retriesLeft: MAX_RETRIES_PER_FRAME,
            attempt: 1,
            assetsOnly: false,
        });
    }));
    await Promise.all(extraFramesToCaptureAssetsBackend.map((frame) => {
        return renderFrameAndRetryTargetClose({
            frame,
            index: null,
            retriesLeft: MAX_RETRIES_PER_FRAME,
            attempt: 1,
            assetsOnly: true,
        });
    }));
    const firstFrameIndex = countType === 'from-zero' ? 0 : framesToRender[0];
    await Promise.all(downloadPromises);
    return {
        assetsInfo: {
            assets: assets.sort((a, b) => {
                return a.frame - b.frame;
            }),
            imageSequenceName: node_path_1.default.join(frameDir, `element-%0${filePadLength}d.${imageFormat}`),
            firstFrameIndex,
            downloadMap,
            trimLeftOffset,
            trimRightOffset,
            chunkLengthInSeconds,
            forSeamlessAacConcatenation,
        },
        frameCount: framesToRender.length,
    };
};
const internalRenderFramesRaw = ({ browserExecutable, cancelSignal, chromiumOptions, composition, concurrency, envVariables, everyNthFrame, frameRange, imageFormat, indent, jpegQuality, muted, onBrowserLog, onDownload, onFrameBuffer, onFrameUpdate, onStart, outputDir, port, puppeteerInstance, scale, server, timeoutInMilliseconds, logLevel, webpackBundleOrServeUrl, serializedInputPropsWithCustomSchema, serializedResolvedPropsWithCustomSchema, offthreadVideoCacheSizeInBytes, parallelEncodingEnabled, binariesDirectory, forSeamlessAacConcatenation, compositionStart, onBrowserDownload, onArtifact, }) => {
    (0, validate_1.validateDimension)(composition.height, 'height', 'in the `config` object passed to `renderFrames()`');
    (0, validate_1.validateDimension)(composition.width, 'width', 'in the `config` object passed to `renderFrames()`');
    (0, validate_1.validateFps)(composition.fps, 'in the `config` object of `renderFrames()`', false);
    (0, validate_1.validateDurationInFrames)(composition.durationInFrames, {
        component: 'in the `config` object passed to `renderFrames()`',
        allowFloats: false,
    });
    (0, jpeg_quality_1.validateJpegQuality)(jpegQuality);
    (0, validate_scale_1.validateScale)(scale);
    const makeBrowser = () => (0, open_browser_1.internalOpenBrowser)({
        browser: browser_1.DEFAULT_BROWSER,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent,
        viewport: null,
        logLevel,
        onBrowserDownload,
    });
    const browserInstance = puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : makeBrowser();
    const resolvedConcurrency = (0, get_concurrency_1.resolveConcurrency)(concurrency);
    const openedPages = [];
    return new Promise((resolve, reject) => {
        const cleanup = [];
        const onError = (err) => {
            reject(err);
        };
        Promise.race([
            new Promise((_, rej) => {
                cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
                    rej(new Error(make_cancel_signal_1.cancelErrorMessages.renderFrames));
                });
            }),
            Promise.all([
                (0, prepare_server_1.makeOrReuseServer)(server, {
                    webpackConfigOrServeUrl: webpackBundleOrServeUrl,
                    port,
                    remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
                    concurrency: resolvedConcurrency,
                    logLevel,
                    indent,
                    offthreadVideoCacheSizeInBytes,
                    binariesDirectory,
                    forceIPv4: false,
                }, {
                    onDownload,
                }),
                browserInstance,
            ]).then(([{ server: openedServer, cleanupServer }, pInstance]) => {
                const { serveUrl, offthreadPort, compositor, sourceMap, downloadMap } = openedServer;
                const browserReplacer = (0, replace_browser_1.handleBrowserCrash)(pInstance, logLevel, indent);
                const cycle = (0, cycle_browser_tabs_1.cycleBrowserTabs)(browserReplacer, resolvedConcurrency, logLevel, indent);
                cleanup.push(() => {
                    cycle.stopCycling();
                    return Promise.resolve();
                });
                cleanup.push(() => cleanupServer(false));
                return innerRenderFrames({
                    onError,
                    pagesArray: openedPages,
                    serveUrl,
                    composition,
                    resolvedConcurrency,
                    onDownload,
                    proxyPort: offthreadPort,
                    makeBrowser,
                    browserReplacer,
                    compositor,
                    sourceMapGetter: sourceMap,
                    downloadMap,
                    cancelSignal,
                    envVariables,
                    everyNthFrame,
                    frameRange,
                    imageFormat,
                    jpegQuality,
                    muted,
                    onBrowserLog,
                    onFrameBuffer,
                    onFrameUpdate,
                    onStart,
                    outputDir,
                    scale,
                    timeoutInMilliseconds,
                    logLevel,
                    indent,
                    serializedInputPropsWithCustomSchema,
                    serializedResolvedPropsWithCustomSchema,
                    parallelEncodingEnabled,
                    binariesDirectory,
                    forSeamlessAacConcatenation,
                    compositionStart,
                    onBrowserDownload,
                    onArtifact,
                });
            }),
        ])
            .then((res) => {
            server === null || server === void 0 ? void 0 : server.compositor.executeCommand('CloseAllVideos', {}).then(() => {
                logger_1.Log.verbose({ indent, logLevel, tag: 'compositor' }, 'Freed memory from compositor');
            }).catch((err) => {
                logger_1.Log.verbose({ indent, logLevel }, 'Could not close compositor', err);
            });
            return resolve(res);
        })
            .catch((err) => reject(err))
            .finally(() => {
            // If browser instance was passed in, we close all the pages
            // we opened.
            // If new browser was opened, then closing the browser as a cleanup.
            if (puppeteerInstance) {
                Promise.all(openedPages.map((p) => p.close())).catch((err) => {
                    if ((0, is_target_closed_err_1.isTargetClosedErr)(err)) {
                        return;
                    }
                    logger_1.Log.error({ indent, logLevel }, 'Unable to close browser tab', err);
                });
            }
            else {
                Promise.resolve(browserInstance)
                    .then((instance) => {
                    return instance.close(true, logLevel, indent);
                })
                    .catch((err) => {
                    if (!(err === null || err === void 0 ? void 0 : err.message.includes('Target closed'))) {
                        logger_1.Log.error({ indent, logLevel }, 'Unable to close browser', err);
                    }
                });
            }
            cleanup.forEach((c) => {
                c();
            });
            // Don't clear download dir because it might be used by stitchFramesToVideo
        });
    });
};
exports.internalRenderFrames = (0, wrap_with_error_handling_1.wrapWithErrorHandling)(internalRenderFramesRaw);
/**
 * @description Renders a series of images using Puppeteer and computes information for mixing audio.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-frames)
 * @param {RenderFramesOptions} options Configuration options for rendering frames.
 * @returns {Promise<RenderFramesOutput>} Information about the rendered frames and assets.
 */
const renderFrames = (options) => {
    const { composition, inputProps, onFrameUpdate, onStart, outputDir, serveUrl, browserExecutable, cancelSignal, chromiumOptions, concurrency, dumpBrowserLogs, envVariables, everyNthFrame, frameRange, imageFormat, jpegQuality, muted, onBrowserLog, onDownload, onFrameBuffer, port, puppeteerInstance, scale, timeoutInMilliseconds, verbose, quality, logLevel: passedLogLevel, offthreadVideoCacheSizeInBytes, binariesDirectory, onBrowserDownload, onArtifact, } = options;
    if (!composition) {
        throw new Error('No `composition` option has been specified for renderFrames()');
    }
    if (typeof jpegQuality !== 'undefined' && imageFormat !== 'jpeg') {
        throw new Error("You can only pass the `quality` option if `imageFormat` is 'jpeg'.");
    }
    const logLevel = verbose || dumpBrowserLogs ? 'verbose' : passedLogLevel !== null && passedLogLevel !== void 0 ? passedLogLevel : 'info';
    const indent = false;
    if (quality) {
        logger_1.Log.warn({ indent, logLevel }, 'Passing `quality()` to `renderStill` is deprecated. Use `jpegQuality` instead.');
    }
    return (0, exports.internalRenderFrames)({
        browserExecutable: browserExecutable !== null && browserExecutable !== void 0 ? browserExecutable : null,
        cancelSignal,
        chromiumOptions: chromiumOptions !== null && chromiumOptions !== void 0 ? chromiumOptions : {},
        composition,
        concurrency: concurrency !== null && concurrency !== void 0 ? concurrency : null,
        envVariables: envVariables !== null && envVariables !== void 0 ? envVariables : {},
        everyNthFrame: everyNthFrame !== null && everyNthFrame !== void 0 ? everyNthFrame : 1,
        frameRange: frameRange !== null && frameRange !== void 0 ? frameRange : null,
        imageFormat: imageFormat !== null && imageFormat !== void 0 ? imageFormat : 'jpeg',
        indent,
        jpegQuality: jpegQuality !== null && jpegQuality !== void 0 ? jpegQuality : jpeg_quality_1.DEFAULT_JPEG_QUALITY,
        onDownload: onDownload !== null && onDownload !== void 0 ? onDownload : null,
        serializedInputPropsWithCustomSchema: no_react_1.NoReactInternals.serializeJSONWithDate({
            indent: undefined,
            staticBase: null,
            data: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        }).serializedString,
        serializedResolvedPropsWithCustomSchema: no_react_1.NoReactInternals.serializeJSONWithDate({
            indent: undefined,
            staticBase: null,
            data: composition.props,
        }).serializedString,
        puppeteerInstance,
        muted: muted !== null && muted !== void 0 ? muted : false,
        onBrowserLog: onBrowserLog !== null && onBrowserLog !== void 0 ? onBrowserLog : null,
        onFrameBuffer: onFrameBuffer !== null && onFrameBuffer !== void 0 ? onFrameBuffer : null,
        onFrameUpdate,
        onStart,
        outputDir,
        port: port !== null && port !== void 0 ? port : null,
        scale: scale !== null && scale !== void 0 ? scale : 1,
        logLevel,
        timeoutInMilliseconds: timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT,
        webpackBundleOrServeUrl: serveUrl,
        server: undefined,
        offthreadVideoCacheSizeInBytes: offthreadVideoCacheSizeInBytes !== null && offthreadVideoCacheSizeInBytes !== void 0 ? offthreadVideoCacheSizeInBytes : null,
        parallelEncodingEnabled: false,
        binariesDirectory: binariesDirectory !== null && binariesDirectory !== void 0 ? binariesDirectory : null,
        compositionStart: 0,
        forSeamlessAacConcatenation: false,
        onBrowserDownload: onBrowserDownload !== null && onBrowserDownload !== void 0 ? onBrowserDownload : (0, browser_download_progress_bar_1.defaultBrowserDownloadProgress)({ indent, logLevel, api: 'renderFrames()' }),
        onArtifact: onArtifact !== null && onArtifact !== void 0 ? onArtifact : null,
    });
};
exports.renderFrames = renderFrames;
